Shortest Cycle
You are given an undirected connected graph with V vertices numbered from 0 to V-1 and E edges, represented as a 2D array edges[][], where each element edges[i] = [u, v] represents an undirected edge between vertex u and v.
Find the length of the shortest cycle in the graph. If the graph does not contain any cycle, return -1.


Note: A cycle is a path that starts and ends at the same vertex without repeating any edge or vertex (except the start/end vertex). The shortest cycle is the one with the minimum number of edges.

Examples

Input: V = 7, E = 8, edges[][] = [[0, 5], [0, 6], [5, 1], [6, 1], [6, 2], [2, 3], [3, 4], [1, 4]]

Output: 4
Explanation: Possible cycles are: 
0 → 5 → 1 → 6 → 0 (length = 4)
1 → 4 → 3 → 2 → 6 → 1 (length = 5)
The smallest one is 0 → 5 → 1 → 6 → 0, with length 4. 
Input: V = 7, E = 9, edges[][] = [[0, 5], [0, 6], [1, 2], [1, 4], [1, 5], [1, 6], [2, 6], [2, 3], [3, 4]]

Output: 3
Explanation: Possible cycles include:
1 → 2 → 6 → 1 (length = 3)
1 → 2 → 3 → 4 → 1 (length = 4)
0 → 5 → 1 → 6 → 0 (length = 4)
The smallest one is 1 → 2 → 6 → 1, with length 3.
Constraints:
1 ≤ V ≤ 103
0 ≤ E ≤ 103
0 ≤ edges[i][0], edges[i][1] < V
Solution:
from collections import deque, defaultdict

class Solution:
    def shortCycle(self, V, edges):
        # Build adjacency list
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        def bfs_shortest_cycle(start):
            """Find shortest cycle passing through start vertex using BFS"""
            dist = [-1] * V
            parent = [-1] * V
            queue = deque([start])
            dist[start] = 0
            min_cycle = float('inf')
            
            while queue:
                u = queue.popleft()
                
                for v in graph[u]:
                    if dist[v] == -1:  # Not visited
                        dist[v] = dist[u] + 1
                        parent[v] = u
                        queue.append(v)
                    elif parent[u] != v:  # Visited but not parent (cycle found)
                        # Cycle length = dist[u] + dist[v] + 1
                        cycle_len = dist[u] + dist[v] + 1
                        min_cycle = min(min_cycle, cycle_len)
            
            return min_cycle
        
        # Try BFS from each vertex to find shortest cycle
        shortest = float('inf')
        for i in range(V):
            if graph[i]:  # Only if vertex has edges
                cycle_len = bfs_shortest_cycle(i)
                shortest = min(shortest, cycle_len)
        
        return shortest if shortest != float('inf') else -1
