Smallest window containing all characters
Difficulty: HardAccuracy: 30.19%Submissions: 180K+Points: 8Average Time: 30m
Given two strings s and p. Find the smallest substring in s consisting of all the characters (including duplicates) of the string p. Return empty string in case no such substring is present.
If there are multiple such substring of the same length found, return the one with the least starting index.

Examples:

Input: s = "timetopractice", p = "toc"
Output: "toprac"
Explanation: "toprac" is the smallest substring in which "toc" can be found.
Input: s = "zoomlazapzo", p = "oza"
Output: "apzo"
Explanation: "apzo" is the smallest substring in which "oza" can be found.
Input: s = "zoom", p = "zooe"
Output: ""
Explanation: No substring is present containing all characters of p.
Constraints: 
1 ≤ s.length(), p.length() ≤ 106
s, p consists of lowercase english letters
Soluction:
class Solution:
    def smallestWindow(self, s, p):
        if not s or not p or len(s) < len(p):
            return ""
        
        # Count characters in pattern p
        p_count = {}
        for char in p:
            p_count[char] = p_count.get(char, 0) + 1
        
        # Number of unique characters in p that need to be matched
        required = len(p_count)
        
        # Sliding window variables
        left = right = 0
        formed = 0  # Number of unique chars in current window with desired frequency
        
        # Dictionary to keep count of characters in current window
        window_counts = {}
        
        # Result
        min_len = float('inf')
        min_left = 0
        
        while right < len(s):
            # Add character from right to window
            char = s[right]
            window_counts[char] = window_counts.get(char, 0) + 1
            
            # Check if current character's frequency matches desired count in p
            if char in p_count and window_counts[char] == p_count[char]:
                formed += 1
            
            # Try to shrink window from left
            while left <= right and formed == required:
                char = s[left]
                
                # Update result if this window is smaller
                if right - left + 1 < min_len:
                    min_len = right - left + 1
                    min_left = left
                
                # Remove character from left of window
                window_counts[char] -= 1
                if char in p_count and window_counts[char] < p_count[char]:
                    formed -= 1
                
                left += 1
            
            right += 1
        
        return "" if min_len == float('inf') else s[min_left:min_left + min_len]
