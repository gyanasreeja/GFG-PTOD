
Max of min for every window size

You are given an integer array arr[], the task is to find the maximum of minimum values for every window size k where 1≤ k ≤ arr.size().

For each window size k, consider all contiguous subarrays of length k, determine the minimum element in each subarray, and then take the maximum among all these minimums.

Return the results as an array, where the element at index i represents the answer for window size i+1.

Examples :

Input: arr[] = [10, 20, 30, 50, 10, 70, 30]
Output: [70, 30, 20, 10, 10, 10, 10] 
Explanation: 
Window size 1: minimums are [10, 20, 30, 50, 10, 70, 30], maximum of minimums is 70.
Window size 2: minimums are [10, 20, 30, 10, 10, 30], maximum of minimums is 30.
Window size 3: minimums are [10, 20, 10, 10, 10], maximum of minimums is 20.
Window size 4–7: minimums are [10, 10, 10, 10], maximum of minimums is 10.
Input: arr[] = [10, 20, 30]
Output: [30, 20, 10]
Explanation: 
Window size 1: minimums of  [10], [20], [30], maximum of minimums is 30.
Window size 2: minimums of [10, 20], [20,30], maximum of minimums is 20.
Window size 3: minimums of [10,20,30], maximum of minimums is 10.
Constraints:
1 ≤ arr.size() ≤ 105
1 ≤ arr[i] ≤ 106class Solution:
    def maxOfMins(self, arr):
        n = len(arr)
        result = [0] * n
        
        # For each element, find the previous smaller element and next smaller element
        # This helps us determine the maximum window size where current element is minimum
        
        # Arrays to store indices of previous and next smaller elements
        prev_smaller = [-1] * n  # previous smaller element index
        next_smaller = [n] * n   # next smaller element index
        
        # Stack to find previous smaller elements
        stack = []
        for i in range(n):
            while stack and arr[stack[-1]] >= arr[i]:
                stack.pop()
            if stack:
                prev_smaller[i] = stack[-1]
            stack.append(i)
        
        # Clear stack for next smaller elements
        stack = []
        for i in range(n-1, -1, -1):
            while stack and arr[stack[-1]] >= arr[i]:
                stack.pop()
            if stack:
                next_smaller[i] = stack[-1]
            stack.append(i)
        
        # For each element, calculate the maximum window size where it's minimum
        for i in range(n):
            # Maximum window size where arr[i] is minimum
            window_size = next_smaller[i] - prev_smaller[i] - 1
            # Update result for this window size with maximum value seen so far
            result[window_size - 1] = max(result[window_size - 1], arr[i])
        
        # Fill remaining positions
        # If no answer exists for window size i, it should be same as window size i+1
        for i in range(n-2, -1, -1):
            result[i] = max(result[i], result[i+1])
        
        return result
