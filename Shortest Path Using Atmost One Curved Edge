
Given an undirected, connected graph with V vertices numbered from 0 to V-1 and E double-edges, represented as a 2D array edges[][]. Each double-edge is represented by a tuple (x, y, w1, w2), which indicates that there are two edges between vertices x and y: a straight edge with weight w1 and a curved edge with weight w2.

You are given two vertices a and b and you have to go from a to b through a series of edges such that in the entire path, you can use at most 1 curved edge. Your task is to find the shortest path from a to b satisfying the above condition.
If no such path exists that satisfies this restriction, return -1.

Note: It is guaranteed that the shortest path value will fit in a 32-bit integer.

Examples:

Input: V = 4, E = 4, a = 1, b = 3, edges[][] = [[0, 1, 1, 4], [0, 2, 2, 4], [0, 3, 3, 1], [1, 3, 6, 5]]

Output: 2
Explanation:
We can follow the path 1 -> 0 -> 3, this gives a distance of 1+3 = 4 if we follow all straight paths. But we can take the curved path  from 0 -> 3, which costs 1. This will result in a cost of 1 + 1 = 2.
Input: V = 2, E = 1, a = 0, b = 1, edges[][] = [[0, 1, 4, 1]]

Output: 1
Explanation:
Take the curved path from 0 to 1 which costs 1. 

Constraints:
1 ≤ V ≤ 106
0 ≤ E ≤ 106
0 ≤ a, b ≤ V - 1
0 ≤ edges[i][0], edges[i][1] ≤ V-1
0 ≤ edges[i][2], edges[i][3] ≤ 104
import heapq
from collections import defaultdict

class Solution:
    def shortestPath(self, V, a, b, edges):
        INF = float('inf')
        
        # Build adjacency list with only straight edges
        graph = defaultdict(list)
        for x, y, w1, w2 in edges:
            graph[x].append((y, w1))
            graph[y].append((x, w1))
        
        def dijkstra(src):
            dist = [INF] * V
            dist[src] = 0
            pq = [(0, src)]  # (distance, node)
            
            while pq:
                d, u = heapq.heappop(pq)
                if d > dist[u]:
                    continue
                for v, w in graph[u]:
                    if dist[u] + w < dist[v]:
                        dist[v] = dist[u] + w
                        heapq.heappush(pq, (dist[v], v))
            return dist
        
        # Get shortest distances using only straight edges
        dist_a = dijkstra(a)  # from source a
        dist_b = dijkstra(b)  # from destination b
        
        # Case 1: All straight edges
        ans = dist_a[b]
        
        # Case 2: Use exactly one curved edge
        for x, y, w1, w2 in edges:
            # Use curved edge from x to y
            if dist_a[x] != INF and dist_b[y] != INF:
                ans = min(ans, dist_a[x] + w2 + dist_b[y])
            # Use curved edge from y to x (undirected)
            if dist_a[y] != INF and dist_b[x] != INF:
                ans = min(ans, dist_a[y] + w2 + dist_b[x])
        
        return ans if ans != INF else -1
