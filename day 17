Sort a linked list of 0s, 1s and 2s

Given the head of a linked list where nodes can contain values 0s, 1s, and 2s only. Your task is to rearrange the list so that all 0s appear at the beginning, followed by all 1s, and all 2s are placed at the end.

Examples:

Input: head = 1 → 2 → 2 → 1 → 2 → 0 → 2 → 2
   
Output: 0 → 1 → 1 → 2 → 2 → 2 → 2 → 2
Explanation: All the 0s are segregated to the left end of the linked list, 2s to the right end of the list, and 1s in between. The final list will be:
   
Input: head = 2 → 2 → 0 → 1
   
Output: 0 → 1 → 2 → 2
Explanation: After arranging all the 0s, 1s and 2s in the given format, the output will be:
   
Constraints:
1 ≤ no. of nodes ≤ 106
0 ≤ node->data ≤ 2
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Solution:
    # Approach 1: Counting Method (2 passes)
    # Time: O(n), Space: O(1)
    def segregate_counting(self, head):
        """
        Count occurrences of 0, 1, 2 and then modify the list
        """
        if not head or not head.next:
            return head
        
        # Count occurrences
        count = [0, 0, 0]  # count[0]=zeros, count[1]=ones, count[2]=twos
        curr = head
        
        while curr:
            count[curr.data] += 1
            curr = curr.next
        
        # Modify the original list
        curr = head
        i = 0
        
        # Fill 0s
        while count[0] > 0 and curr:
            curr.data = 0
            curr = curr.next
            count[0] -= 1
        
        # Fill 1s
        while count[1] > 0 and curr:
            curr.data = 1
            curr = curr.next
            count[1] -= 1
        
        # Fill 2s
        while count[2] > 0 and curr:
            curr.data = 2
            curr = curr.next
            count[2] -= 1
        
        return head
    
    # Approach 2: Three Pointers Method (1 pass) - OPTIMAL
    # Time: O(n), Space: O(1)
    def segregate(self, head):
        """
        Create three separate chains for 0s, 1s, and 2s, then connect them
        """
        if not head or not head.next:
            return head
        
        # Create dummy nodes for three chains
        zero_head = Node(-1)
        one_head = Node(-1)
        two_head = Node(-1)
        
        # Pointers to build the chains
        zero_tail = zero_head
        one_tail = one_head
        two_tail = two_head
        
        curr = head
        
        # Traverse and segregate
        while curr:
            if curr.data == 0:
                zero_tail.next = curr
                zero_tail = curr
            elif curr.data == 1:
                one_tail.next = curr
                one_tail = curr
            else:  # curr.data == 2
                two_tail.next = curr
                two_tail = curr
            
            curr = curr.next
        
        # Connect the three chains
        # Connect zeros to ones (or twos if no ones exist)
        if one_head.next:
            zero_tail.next = one_head.next
        else:
            zero_tail.next = two_head.next
        
        # Connect ones to twos
        one_tail.next = two_head.next
        
        # End the list
        two_tail.next = None
        
        return zero_head.next
    
    # Approach 3: Dutch National Flag Algorithm Adaptation
    # Time: O(n), Space: O(1)
    def segregate_dutch_flag(self, head):
        """
        Adaptation of Dutch National Flag algorithm for linked lists
        """
        if not head or not head.next:
            return head
        
        # Convert to array for easier manipulation
        values = []
        curr = head
        while curr:
            values.append(curr.data)
            curr = curr.next
        
        # Apply Dutch National Flag algorithm
        low, mid, high = 0, 0, len(values) - 1
        
        while mid <= high:
            if values[mid] == 0:
                values[low], values[mid] = values[mid], values[low]
                low += 1
                mid += 1
            elif values[mid] == 1:
                mid += 1
            else:  # values[mid] == 2
                values[mid], values[high] = values[high], values[mid]
                high -= 1
                # Don't increment mid here as we need to check swapped element
        
        # Update linked list with sorted values
        curr = head
        for val in values:
            curr.data = val
            curr = curr.next
        
        return head

# Helper functions for testing
def create_linked_list(arr):
    """Create a linked list from array"""
    if not arr:
        return None
    
    head = Node(arr[0])
    curr = head
    for i in range(1, len(arr)):
        curr.next = Node(arr[i])
        curr = curr.next
    return head

def print_linked_list(head):
    """Print linked list"""
    result = []
    curr = head
    while curr:
        result.append(str(curr.data))
        curr = curr.next
    return " → ".join(result)
