
You are given a 2D array mat[][], of size n*m. Your task is to find the minimum possible path cost from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1) by moving up, down, left, or right between adjacent cells.

Note: The cost of a path is defined as the maximum absolute difference between the values of any two consecutive cells along that path.

Examples:

Input: mat[][] = [[7, 2, 6, 5],
               [3, 1, 10, 8]]
Output: 4
Explanation: The route of [7, 3, 1, 2, 6, 5, 8] has a minimum value of maximum absolute difference between any two consecutive cells in the route, i.e., 4.
   
Input: mat[][] = [[2, 2, 2, 1],
               [8, 1, 2, 7],
               [2, 2, 2, 8],
               [2, 1, 4, 7],
               [2, 2, 2, 2]]
Output: 0
Explanation: The route of [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] has a minimum value of maximum absolute difference between any two consecutive cells in the route, i.e., 0.
    Solution:
import heapq

class Solution:
    def minCostPath(self, mat):
        n = len(mat)
        m = len(mat[0])
        
        # Edge case: single cell
        if n == 1 and m == 1:
            return 0
        
        # Min-heap: (effort, row, col)
        pq = [(0, 0, 0)]
        
        # Track minimum effort to reach each cell
        effort = [[float('inf')] * m for _ in range(n)]
        effort[0][0] = 0
        
        # Directions: up, down, left, right
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        while pq:
            curr_effort, row, col = heapq.heappop(pq)
            
            # If we reached the destination
            if row == n - 1 and col == m - 1:
                return curr_effort
            
            # If we've already found a better path to this cell, skip
            if curr_effort > effort[row][col]:
                continue
            
            # Explore all 4 directions
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                # Check bounds
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate the effort for this move
                    new_effort = max(curr_effort, abs(mat[row][col] - mat[new_row][new_col]))
                    
                    # If we found a better path to the neighbor
                    if new_effort < effort[new_row][new_col]:
                        effort[new_row][new_col] = new_effort
                        heapq.heappush(pq, (new_effort, new_row, new_col))
        
        return effort[n-1][m-1]
