
Given a binary grid[][], where each cell contains either 0 or 1, find the distance of the nearest 1 for every cell in the grid.
The distance between two cells (i1, j1)  and (i2, j2) is calculated as |i1 - i2| + |j1 - j2|. 
You need to return a matrix of the same size, where each cell (i, j) contains the minimum distance from grid[i][j] to the nearest cell having value 1.

Note: It is guaranteed that there is at least one cell with value 1 in the grid.

Examples

Input: grid[][] = [[0, 1, 1, 0], 
                [1, 1, 0, 0], 
                [0, 0, 1, 1]]
Output: [[1, 0, 0, 1], 
        [0, 0, 1, 1], 
        [1, 1, 0, 0]]
Explanation: The grid is -

- 0's at (0,0), (0,3), (1,2), (1,3), (2,0) and (2,1) are at a distance of 1 from 1's at (0,1), (0,2), (0,2), (2,3), (1,0) and (1,1) respectively.

Input: grid[][] = [[1, 0, 1], 
                [1, 1, 0], 
                [1, 0, 0]]
Output: [[0, 1, 0], 
        [0, 0, 1], 
        [0, 1, 2]]
Explanation: The grid is -

- 0's at (0,1), (1,2), (2,1) and (2,2) are at a  distance of 1, 1, 1 and 2 from 1's at (0,0), (0,2), (2,0) and (1,1) respectively.

Constraints:
1 ≤ grid.size() ≤ 200
1 ≤ grid[0].size() ≤ 200
class Solution:
    def nearest(self, grid):
        from collections import deque
        
        n = len(grid)
        m = len(grid[0])
        
        # Result matrix to store distances
        result = [[float('inf')] * m for _ in range(n)]
        
        # Queue for BFS: stores (row, col, distance)
        queue = deque()
        
        # Add all cells with 1 to the queue with distance 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    queue.append((i, j, 0))
                    result[i][j] = 0
        
        # Directions: up, down, left, right
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        # Perform multi-source BFS
        while queue:
            row, col, dist = queue.popleft()
            
            # Explore all 4 neighbors
            for dr, dc in directions:
                new_row = row + dr
                new_col = col + dc
                
                # Check if new position is valid and not yet visited
                if (0 <= new_row < n and 0 <= new_col < m 
                    and result[new_row][new_col] > dist + 1):
                    
                    result[new_row][new_col] = dist + 1
                    queue.append((new_row, new_col, dist + 1))
        
        return result
